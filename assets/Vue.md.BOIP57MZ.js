import{_ as a,c as o,o as u,as as e,j as i,a as t,t as r}from"./chunks/framework.DopOb1th.js";const S=JSON.parse('{"title":"Vue.js 框架全景","description":"","frontmatter":{},"headers":[],"relativePath":"Vue.md","filePath":"Vue.md"}'),s={name:"Vue.md"};function n(d,l,_,p,P,h){return u(),o("div",null,[l[7]||(l[7]=e('<h1 id="vue-js-框架全景" tabindex="-1">Vue.js 框架全景 <a class="header-anchor" href="#vue-js-框架全景" aria-label="Permalink to &quot;Vue.js 框架全景&quot;">​</a></h1><h2 id="_1-定位与特点" tabindex="-1">1. 定位与特点 <a class="header-anchor" href="#_1-定位与特点" aria-label="Permalink to &quot;1. 定位与特点&quot;">​</a></h2><ul><li>渐进式 : 可只当视图层库，也可配合生态做 SPA / SSR / 跨端</li><li>响应式 : 基于 Proxy 的依赖追踪</li><li>组件化 : 单文件组件 SFC（*.vue）</li><li>轻量高效 : 运行时 ~20kB(gzip)</li><li>开发体验 <ul><li>单文件组件 + Vite 热更新</li><li>Devtools 调试</li><li>TypeScript 一等公民</li></ul></li></ul><h2 id="_2-核心概念" tabindex="-1">2. 核心概念 <a class="header-anchor" href="#_2-核心概念" aria-label="Permalink to &quot;2. 核心概念&quot;">​</a></h2>',4)),i("ul",null,[l[3]||(l[3]=e("<li>响应式系统 <ul><li>ref / reactive</li><li>effect / watch / computed</li><li>依赖收集 &amp; 触发更新</li></ul></li><li>组件系统 <ul><li>Props / Emits</li><li>Slots</li><li>Provide / Inject</li><li>生命周期 <ul><li>Options API: beforeCreate -&gt; destroyed</li><li>Composition API: onXxx</li></ul></li></ul></li>",2)),i("li",null,[l[2]||(l[2]=t("模板语法 ")),i("ul",null,[i("li",null,"插值 "+r(),1),l[0]||(l[0]=i("li",null,"指令 v-if / v-for / v-on / v-bind",-1)),l[1]||(l[1]=i("li",null,"修饰符 .prevent .sync 等",-1))])]),l[4]||(l[4]=i("li",null,"虚拟 DOM & Diff",-1)),l[5]||(l[5]=i("li",null,"事件系统",-1)),l[6]||(l[6]=i("li",null,[t("动画 "),i("code",null,"<Transition>"),t(" / "),i("code",null,"<TransitionGroup>")],-1))]),l[8]||(l[8]=e('<h2 id="_3-单文件组件-sfc" tabindex="-1">3. 单文件组件 SFC <a class="header-anchor" href="#_3-单文件组件-sfc" aria-label="Permalink to &quot;3. 单文件组件 SFC&quot;">​</a></h2><ul><li><code>&lt;template&gt;</code> 模板</li><li><code>&lt;script setup&gt;</code> 组合式语法糖</li><li><code>&lt;style scoped&gt;</code> / CSS Modules</li><li>预处理器 Sass / Less / Stylus</li></ul><h2 id="_4-周边生态" tabindex="-1">4. 周边生态 <a class="header-anchor" href="#_4-周边生态" aria-label="Permalink to &quot;4. 周边生态&quot;">​</a></h2><ul><li>官方 <ul><li>路由 Vue Router</li><li>状态管理 Pinia（Vuex 退役）</li><li>构建工具 Vite</li><li>服务端渲染 Nuxt 3</li><li>桌面/移动 Tauri / NativeScript / uni-app</li></ul></li><li>社区 <ul><li>UI 组件库 Element Plus / Ant Design Vue / Naive UI</li><li>静态站点 VitePress</li><li>微前端 qiankun / wujie</li><li>测试 Vue Test Utils / Cypress / Vitest</li></ul></li></ul><h2 id="_5-版本演进" tabindex="-1">5. 版本演进 <a class="header-anchor" href="#_5-版本演进" aria-label="Permalink to &quot;5. 版本演进&quot;">​</a></h2><ul><li>Vue 2.x <ul><li>响应式 Object.defineProperty</li><li>选项式 API</li></ul></li><li>Vue 3.x <ul><li>Composition API</li><li>Proxy 响应式</li><li>性能提升 1.3~2x</li><li>Tree-shaking</li><li>Fragment / Teleport / Suspense</li></ul></li><li>Vue 2.7 &quot;Naruto&quot; : 向后移植部分 Composition API</li></ul><h2 id="_6-常见模式" tabindex="-1">6. 常见模式 <a class="header-anchor" href="#_6-常见模式" aria-label="Permalink to &quot;6. 常见模式&quot;">​</a></h2><ul><li>组合式函数 Composable</li><li>逻辑复用 hooks</li><li>依赖注入 Provide/Inject</li><li>高阶组件 HOC / Renderless 组件</li></ul><h2 id="_7-性能优化" tabindex="-1">7. 性能优化 <a class="header-anchor" href="#_7-性能优化" aria-label="Permalink to &quot;7. 性能优化&quot;">​</a></h2><ul><li>v-memo / v-once</li><li>KeepAlive</li><li>异步组件 defineAsyncComponent</li><li>懒加载路由</li><li>虚拟列表 vue-virtual-scroller</li></ul><h2 id="_8-学习路线" tabindex="-1">8. 学习路线 <a class="header-anchor" href="#_8-学习路线" aria-label="Permalink to &quot;8. 学习路线&quot;">​</a></h2><ul><li>基础 <ul><li>模板语法</li><li>组件通信</li><li>生命周期</li></ul></li><li>进阶 <ul><li>组合式 API</li><li>自定义指令 / 插件</li><li>单元测试</li></ul></li><li>实战 <ul><li>用 Vite + Pinia + Vue Router 搭项目</li><li>SSR or SSG（Nuxt / VitePress）</li><li>TypeScript 全流程</li></ul></li></ul>',12))])}const V=a(s,[["render",n]]);export{S as __pageData,V as default};
